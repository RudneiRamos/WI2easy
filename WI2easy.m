(* ::Package:: *)

(* 
WI2easy: a package for solving the background and first order scalar perturbation
equations in warm inflation

Summary:

   Wi2easy provides a set of tools for the dynamical evolution for the 
   background and first order perturbations in warm inflation. 
   It can handle general inflationary potentials (both small and large 
   inflaton field models) as also generic forms for the dissipation 
   coefficient. 

Authors:

  Gabriel S. Rodrigues (Rio de Janeiro State U.)
  Rudnei O. Ramos (Rio de Janeiro State U.)

History:

   v1.0 - first release

Reference:

  [arXiv:2504.XXXXX]
  
Copyright: \[Copyright]2025
 
Disclaimer: The authors are not responsible for the inappropriate or incorrect
use of this software . The users are fully responsible to make sure that they are
applying the supplied software and routines in a correct and consistent way. 

*)

(* Mathematica Package *)
$ContextPath = Prepend[$ContextPath, "WI2easy`Private`"];

Print["This is WI2easy v1.0"];


BeginPackage["WI2easy`"]
(* Exported symbols added here with SymbolName::usage *)  

ParametersWI::usage="
ParametersWI[] where all relevant definitions and parameters for the different parts of the code are given.
";

FindICs::usage="
FindICs[Qi_,Qf_] runs the background equations and finds the appropriate initial conditions for values of the dissipation ratio Q in the interval [Qi,Qf]. The results are saved in the data files ICs_data and cp_data
";

FindGQ::usage="
FindGQ[] computes the growing function G(Q) multiplying the analytical spectrum in WI. It runs the background and perturbation equations and compute the  scalar of curvature power spectrum, using the Fokker-Planck method,  for values of  the dissipation ratio Q in the interval [Qi,Qf]. It requires the data files generated by FindICs[Qi_,Qf_] (you do not need to run FindICs[Qi_,Qf_] if you already have the data files for the specific model  under study). The results are saved in the data file G(Q)_data
";

ObservationsWI::usage="
ObservationsWI[Q0spec_,x0value_] normalizes the spectrum and computes the relevant observables (e.g. the spectral tilt, the tensor-to-scalar ratio, running, etc) for the specified value of Q0 and with initial value for the  inflaton amplitude x0. The value for  the dissipation ratio Q0  must be in the interval [Qi,Qf] used to obtain G(Q). It requires the data files produced by FindICs[Qi_,Qf_] and FindGQ[] (you do not need to run FindICs[Qi_,Qf_] and FindGQ[] if you already have the data files for the specific model  under study)
";

QrangeWI::usage="
QrangeWI[QVal_] normalizes the spectrum and computes the relevant observables (e.g. the spectral tilt, the tensor-to-scalar ratio, running, along also with some relevant background quantities) for different values of Qstar (Q at Hubble crossing), starting at the value QVal.  It requires the data files  produced by FindICs[Qi_,Qf_] and FindGQ[]  (you do not need to run FindICs[Qi_,Qf_] and FindGQ[] if you already have the data files generated by them for the specific model  under study). The results are saved in the data file observables_data
";

DefinitionsWI::usage="
DefinitionsWI[] used for internal parameters definitions
";

EqsWI::usage="
EqsWI[] file where WI equations and differential equations code  are defined
";

BackgroundWI0::usage="
BackgroundWI0[] internal code to solve the background equations (V0 is fixed by the initial value supplied by the user)
";

BackgroundWI::usage="
BackgroundWI[] internal code to solve the background equations and also find the appropriate normalization V0 for the potential
";

odesolver0::usage="
odesolver0[nefolds_] internal solver for the background differential equations
";

odesolver1::usage="
odesolver1[nefolds_] internal solver for the background differential equations
";


Begin["`Private`"] (* Begin Private Context *) 

ParametersWI[]:=Module[{},
SetDirectory[NotebookDirectory[]];

potential=Null;
V0init=Null;
xc=Null;
x0i=Null;
funcdiss=Null;
gstar0=Null;
extras=Null;
CreateDialog[Column[{Text["Please enter the model and parameters:"],
Grid[{{"Inflaton Potential:",InputField[Dynamic[potential],Expression,FieldHint->"e.g., V0*x^4/4"]},
{"V0 normalization (in Mp units):",InputField[Dynamic[V0init],Expression,FieldHint->"e.g., 10^(-14)"]},
{"Potential shape:",PopupMenu[Dynamic[max],{0->"Large field potential",1->"Small field potential"}]},
{Dynamic[If[max==0,Column[{"Hybrid inflation?",PopupMenu[Dynamic[hybrid],{0->"No",1->"Yes"}]},Spacings->1],Nothing],
TrackedSymbols:>{max}],SpanFromLeft},{Dynamic[If[hybrid==1&&max==0,
Column[{"Critical inflaton value (in Mp units):",InputField[Dynamic[xc],Expression,FieldHint->"Value in Mp units"]}],Nothing],
TrackedSymbols:>{hybrid}],SpanFromLeft},
{"Potential name:",InputField[Dynamic[pottype],String,FieldHint->"e.g., quartic-monomial"]},
{"Initial inflaton field (in Mp units):",InputField[Dynamic[x0i],Expression,FieldHint->"Value in Mp units"]},
{"Functional dependence of the dissipation coefficient:",
InputField[Dynamic[funcdiss],Expression,FieldHint->"e.g., T^3/x^2"]},
{"Dissipation name:",InputField[Dynamic[disstype],String,FieldHint->"e.g., cubicT"]},
{"Thermalized fluctuations?",PopupMenu[Dynamic[thermal],{0->"No",1->"Yes"}]},
{"Radiation noise?",PopupMenu[Dynamic[radnoise],{0->"No",1->"Yes"}]},
{"Relativistic DoF (g*):",InputField[Dynamic[gstar0],Expression,FieldHint->"e.g., 106.75"]},
{"Number of e-folds (Ne):",InputField[Dynamic[Ns],Number,FieldHint->"Typical: value between 50-60"]},
{"Defining extra parameters?",PopupMenu[Dynamic[extra],{0->"No",1->"Yes"}]},
{Dynamic[If[extra==1,"Define extra constants here:" InputField[Dynamic[extras],Expression,FieldHint->"a=1; b=2;..."],Nothing],
TrackedSymbols:>{extra}],SpanFromLeft}},Alignment->{Right,Center},Spacings->{1,1}],
Row[{Button["Submit",DialogReturn[pars=<|"Potential"->potential,"V0"->V0init,"PotentialType"->pottype,
"HybridPotential"->If[hybrid==1,{"YES","criticalfieldvalue"->xc},"NO"],
"InitialField"->x0i,"Dissipation"->funcdiss,"DissipationType"->disstype,
"PotentialShape"->max,"Thermalized"->thermal,"RadNoise"->radnoise,
"gstar"->gstar0,"Nefolds"->Ns,"ExtraParams"->If[extra==1,"YES","NO"]|>],
Enabled->Dynamic[potential=!=""&&V0init=!=""&&pottype=!=""&&x0i=!=""&&funcdiss=!=""&&disstype=!=""]],
Button["Help",CreateDialog[Column[{Text[Style["Help for Parameters",Bold,16]],
Grid[{{"Inflaton Potential","Give the inflaton potential. Write it in the form  V0 function(x), where V0 is the normalization of the potential and x is the inflaton field (in reduced Planck  mass units), e.g. V0 x^4/4."},
{"V0 normalization","Give a value for V0. It sets the normalization energy scale for the potential (in reduced Planck mass units). Choose a value close to the one for cold inflation(e.g., 10^(-14)). Note: this is only used to generate the initial conditions used to produce the function G(Q). When evaluating the  observables (ns, r, etc), it will be evaluated self-consistently."},
{"Potential shape","Initial shape: it is where in the potential the inflaton starts, whether it starts away from origin (phi=0), like in large field models, or in a plateau at the origin (phi=0), like in small field models."},
{"Hybrid inflation?","If YES: provide the value of the critical inflaton field phi_cr (in reduced Planck mass units)."},
{"Potential name","Type a simple name (identifier) for the potential (e.g., 'quartic-monomial')."},
{"Initial inflaton field"," Give a value for the inflaton field (in reduced Planck mass units) to be used in the search algorithm of the initial conditions. It should be a value close to the one found for cold inflation when using the same potential and for the chosen value of total e-folds of inflation."},
{"Dissipation coefficient","Give the expression for the dissipation coefficient Upsilon/Cups. Typically it is of the form T^c*x^p*Mp^(1-p-c), a function of T and x (the inflaton amplitude) (in reduced Planck mass units). Do not multiply by the overal constant Cupilon. It will be added automatically in the code. Examples: T^3/x^2, T^3, T, etc."},
{"Dissipation name","Type a simple name (identifier) for the dissipation coefficient (e.g., 'cubicT')."},
{"Thermalized fluctuations","Wheter to include thermal fluctuations in the dynamics for the perturbations or not (this is model dependent, whether the inflaton fluctuations are thermalized or not)."},
{"Radiation noise","Include the noise term from radiation or not (see the paper for explanations). Typically answer yes."},
{"Relativistic DoF (g*)","Give the number of relativistic degrees of freedom. Some examples: 106.75 (for standard model), 228.75 (for a minimal supersymmetric model), etc."},
{"Number of e-folds (Ne)","Give the number of e-folds that you want inflation to last (a value between 50-60 is typical)."},
{"Extra parameters","Do you have any model dependent constants that you need to define (e.g. additional constants appearing in the potential, dissipation coefficient, etc) ? If yes, you can define them here (in Mathematica format and defined one after the other (e.g., a1=1; a2=2; etc)."}},Alignment->{{Left,Left},Automatic},Dividers->All,Spacings->{2,1},Frame->True]},
Spacings->2],WindowTitle->"Parameter Help",WindowSize->{Automatic,Automatic}],Appearance->"Palette"]},Spacer[10]]},
Spacings->2],WindowTitle->"Warm Inflation Model and Parameters"];
(*Print[pars];*)
];

(*SetOptions[OpenWrite,PageWidth->Infinity];
filedata=OpenWrite["WI2easy_global-parameters.dat"];
Write[filedata, potential];
Write[filedata,FortranForm[V0init]];
Write[filedata,pottype];
Write[filedata,max];
Write[filedata,hybrid];
If[hybrid == 1, 
Write[filedata,"xc=" xc];
  ];
Write[filedata,FortranForm[x0i]];
Write[filedata,funcdiss];
Write[filedata,disstype];
Write[filedata,thermal];
Write[filedata,radnoise];
Write[filedata,gstar0];
Write[filedata,Ns];
If[extra == 1, 
Write[filedata,"Extra parameters=True"];
  ];
Close[filedata];
Clear[filedata];*)

RefLink[Off,paclet:ref/Off][General::shdw]
 Off[General::shdw]
 Off[NSolve::ratnz]
 Off[Solve::ratnz]
 Off[CreateDirectory::eexist]


DefinitionsWI[]:=Module[{},
SetDirectory[NotebookDirectory[]];
SetOptions[OpenWrite,PageWidth->Infinity];
(* Method used by NDSolve when solving the differential background equations to find the ICs *)
methodODE0={Method->{"StiffnessSwitching"},AccuracyGoal->12, PrecisionGoal->12};
(* Method used by NDSolve when solving the differential background equations to find CMB relevant quantities *)
methodODE1={Method->{"StiffnessSwitching"},AccuracyGoal->16, PrecisionGoal->16};
(* Method used by NDSolve when solving the differential perturbation equations to find G(Q) *)
methodODE2={Method->{"StiffnessSwitching"}(*,AccuracyGoal->12, PrecisionGoal->12*)};

(* Pivot scale: *)
kpivotscale=0.05;
(* correct amplitude according to the scale k_pivot *)
ampl=3.047-(0.9658-1)*Log[0.05/kpivotscale];
Pcurv=Exp[ampl]*10^(-10);
(* h parameter *)
hhubble=0.6766; 
(* CMB temperature in GeV *)
TCMB=2.3482233142482267*10^(-13);
(* H0 in GeV *)
Hubble0=hhubble*2.1331720137492583*10^(-42);
(* convert pivot scale in GeV *)
kpivot = kpivotscale/(1.564*10^(38));

(* All quantities are in units of reduced Planck mass Mp=1.2211*10^(19)/Sqrt[8Pi] *)
Mp=1;

(* Some quantities also depend explicitly om Mp, so keep it here *)
Mpl=1.2211*10^(19)/Sqrt[8Pi];

(* How far back from Ns *)
Nback=7;
(* Total number of efolds to find the backgound ICs: *)
Ntot=Ns;
(* Total number of efolds starting from Nback to compute the spectrum: *)
Npert=2*Nback;
(* The dissipation coefficient \Upsilon *)
Upsilon=CUpsilon*funcdiss;

(* Include quantum noise or not: *)
If[thermal==1,
{qnoise=1;
ics=0;},
{qnoise=0;
ics=1;(* Include ICs or not: *)}];

Cr0=N[Pi^2*gstar0/30];

(* initial  value for \phi for seach algorithn: choose a value close to the cold inflation case for the given potential *)
xi=x0i;

radn=If[radnoise==1,"withradnoise","noradnoise"];
thermn=If[thermal==1,"withthermal","nonthermal"];
quanting=Which[qnoise==1,"quantum-noise",ics==1,"BD-ICs"];
efoldstot=ToString@AccountingForm[Ns,{12,10}];

(* Files where data are saved *)
fileICs=StringJoin["ICs_data_","potential=",pottype,"_dissip=",disstype,"_Ne=",efoldstot,"_",radn,"_",thermn,"_",quanting,".dat"];
filepowers=StringJoin["cp_data_","potential=",pottype,"_dissip=",disstype,"_Ne=",efoldstot,"_",radn,"_",thermn,"_",quanting,".dat"];
fileGQ=StringJoin["G(Q)_data_","potential=",pottype,"_dissip=",disstype,"_Ne=",efoldstot,"_",radn,"_",thermn,"_",quanting,".dat"];
fileobs=StringJoin["observables_data_","potential=",pottype,"_dissip=",disstype,"_Ne=",efoldstot,"_",radn,"_",thermn,"_",quanting,".dat"];

directoryPath=StringJoin[pottype,"/",disstype];
CreateDirectory[directoryPath,CreateIntermediateDirectories->True];
fileICs=StringJoin[directoryPath,"/",fileICs];
filepowers=StringJoin[directoryPath,"/",filepowers];
fileGQ=StringJoin[directoryPath,"/",fileGQ];
fileobs=StringJoin[directoryPath,"/",fileobs];
];


EqsWI[]:=Module[{},
(* The inflaton potential *)
Clear[V0,pot];
pot=potential;
(* derivatives of the inflaton potential *)
dpot=D[pot,x];
ddpot=D[pot,{x,2}];
d3pot=D[pot,{x,3}];
d4pot=D[pot,{x,4}];
(* *************************************** *)
H=Sqrt[1/(3 Mp^2)(dphi^2/2+pot+rad)];
Hsr=Sqrt[1/(3 Mp^2)pot];
(* the dissipation coefficient rate Q *)
Q=Upsilon/(3*H)/.{x->phi,T->(rad/Cr0)^(1/4)};
dphistarn=-dpotstar/(3*Hstar(1+Qstar));
rad0=3*Qstar*dphii^2/4;
z[t_]=H/.{rad->r[t], dphi->y[t],phi->x[t],x-> x[t]};
(* The Dissipation coefficient in the dimensionless variables *)
Tt[t_]=(rad/Cr0)^(1/4)/.{rad->r[t], dphi->y[t],phi->x[t],x-> x[t]};
Q0[t_] = Q/.{T->Tt[t]}/.{rad->r[t], dphi->y[t],phi->x[t],x-> x[t]};
epsilon[t_]=((-D[z[t],t]/z[t])/.{x'[t]-> y[t]/z[t],
y'[t]-> -3(1+Q0[t])y[t]-(dpot/.{x->x[t]})/z[t],r'[t]-> -4r[t]+3Q0[t]y[t]^2});
stopCondition[t_,xVal_,yVal_,rVal_,V0_]=If[hybrid==0,Re[epsilon[t]],xc/x[t]]/.{x[t]->xVal,y[t]->yVal,r[t]->rVal};
sys={x'[t]==y[t]/z[t],y'[t]==-3(1+Q0[t])y[t]-(dpot/.{x->x[t]})/z[t],
r'[t]==-4r[t]+3Q0[t]y[t]^2};
(* Slow-roll equations (valid for cubic T^c phi^p M^{1-c-p} dissipation) :(dimensionless units) *) 
etasr=(ddpot/pot);
epsilonsr=(1/2)*(dpot/pot)^2;
sigmasr=dpot/(pot*x);
dxdNsra=-x*sigmasr/(1+Qe);
dQdNsra=(2 Qe ((2+cTx) epsilonsr-cTx etasr-2 pTx sigmasr))/(4-cTx+(4+cTx) Qe);
dvdNsra=((-2 etasr (1+Qe)+epsilonsr*(7+cTx (-1+Qe)+5 Qe)+pTx (-1+Qe) sigmasr) ve)/((1+Qe)*(4-cTx+(4+cTx) Qe));
(* Perturbations involve derivatives of Upsilon: *)
deltaUpsilon=(coupT*D[Upsilon,T]*T*\[Delta]\[Rho]r/(4*r)+D[Upsilon,x]*\[Delta]\[Phi])/.{CUpsilon->Cups};
(* Perturbation Equations *)
dHdt=-1/2*(y^2+4/3 r);
d2\[Delta]\[Phi]dN2=-(dHdt/z^2+3(1+Qe))d\[Delta]\[Phi]dN-1/z^2(k^2/a^2 + ddpot)\[Delta]\[Phi]-deltaUpsilon*y/z^2-1/z^2(3z(1+Qe)y + 2 dpot)\[Alpha]+y (\[Kappa]+d\[Alpha]dt)/z^2+1/(z*a)^(3/2)*Sqrt[6z Qe T]*Subscript[\[Xi], \[Phi]]+1/(z*a)^(3/2)*Sqrt[ z^2 Sqrt[9+12*Pi*Qe]/Pi*(1+thermal*2/(Exp[ z/T]-1))]*Subscript[\[Xi], q];
d\[Delta]\[Rho]rdN=-4\[Delta]\[Rho]r+deltaUpsilon*y^2/z+k^2/a^2/z*\[Psi]r+6z Qe y d\[Delta]\[Phi]dN+1/z(4/3 r)*\[Kappa]+3(-4/3 r - Qe y^2) \[Alpha]-z*y/(z*a)^(3/2)*Sqrt[6z Qe T]*Subscript[\[Xi], \[Rho]r] ;
d\[Psi]rdN=-3*\[Psi]r -\[Delta]\[Rho]r/(3*z)-3Qe y \[Delta]\[Phi] -1/z(4/3 r )\[Alpha];
\[Kappa]=-1/2/z(y z d\[Delta]\[Phi]dN -y^2 \[Alpha] + dpot \[Delta]\[Phi] + \[Delta]\[Rho]r);
\[Alpha]=1/2/z( y \[Delta]\[Phi] - \[Psi]r);
d\[Alpha]dt=-dHdt/z*\[Alpha] - 1/2/z(3z(1+Qe)y+dpot)\[Delta]\[Phi]+y/2 d\[Delta]\[Phi]dN-1/2 d\[Psi]rdN;
\[Chi]=a^2/k^2 (\[Kappa] -3 z \[Alpha]);
(* matrix A elements *)
(* terms for d \delta\phi/dN equation *)
a11=0;
a12=-1;
a13=0;
a14=0;
(* terms for d^2 \delta\phi/dN^2 equation *)
a21=-Coefficient[d2\[Delta]\[Phi]dN2,\[Delta]\[Phi]];
a22=-Coefficient[d2\[Delta]\[Phi]dN2,d\[Delta]\[Phi]dN];
a23=-Coefficient[d2\[Delta]\[Phi]dN2,\[Delta]\[Rho]r];
a24=-Coefficient[d2\[Delta]\[Phi]dN2,\[Psi]r];
(* terms for d \delta\rhorad/dN equation *)
a31=-Coefficient[d\[Delta]\[Rho]rdN,\[Delta]\[Phi]];
a32=-Coefficient[d\[Delta]\[Rho]rdN,d\[Delta]\[Phi]dN];
a33=-Coefficient[d\[Delta]\[Rho]rdN,\[Delta]\[Rho]r]; 
a34=-Coefficient[d\[Delta]\[Rho]rdN,\[Psi]r];
(* terms for d \Psi_R/dN -- radiation momentum perturbation equation *)
a41=-Coefficient[d\[Psi]rdN,\[Delta]\[Phi]];
a42=-Coefficient[d\[Psi]rdN,d\[Delta]\[Phi]dN];
a43=-Coefficient[d\[Psi]rdN,\[Delta]\[Rho]r];
a44=-Coefficient[d\[Psi]rdN,\[Psi]r];
Amatrix={{a11,a12,a13,a14},
{a21,a22,a23,a24},
{a31,a32,a33,a34},
{a41,a42,a43,a44}};
(* colunm matrix B for the noise terms *)
b2=Sqrt[Coefficient[d2\[Delta]\[Phi]dN2,Subscript[\[Xi], \[Phi]]]^2+Coefficient[d2\[Delta]\[Phi]dN2,Subscript[\[Xi], q]]^2*qnoise+Coefficient[d2\[Delta]\[Phi]dN2,Subscript[\[Xi], \[Rho]r]]^2*radnoise];
(* We only need to account for the noise in the original radiation perturbation equation 
and also in the momentum perturbation *)
b3=Coefficient[d\[Delta]\[Rho]rdN,Subscript[\[Xi], \[Rho]r]]*radnoise;
b4=Coefficient[d\[Psi]rdN,Subscript[\[Xi], \[Psi]]];
(* Construct the matrix of the noises: only the diagonal elements contribute, assuming different noises are uncorrelated, \langle \xi_i \xi_j \rangle
=\delta_{ij} *)
Bmatrix=DiagonalMatrix[{0,b2,b3,b4}];
J[t_]={{j11[t],j12[t],j13[t],j14[t]},
{j21[t],j22[t],j23[t],j24[t]},
{j31[t],j32[t],j33[t],j34[t]},
{j41[t],j42[t],j43[t],j44[t]}
};
syspert0={
J'[t]==-Amatrix . J[t]-J[t] . Transpose[Amatrix]+Bmatrix . Transpose[Bmatrix]}/.{a-> a[t],x->x[t],y-> y[t],r-> r[t],T->Tt[t],z->z[t],Qe->Qp[t]}/.{rad->r[t], dphi->y[t],phi->x[t]};
ICspert0={J[0]==ics*1/(2*k*a0^2)*({{1,-1+(I k)/H0,0,0},{-1-(I k)/H0,1+k^2/H0^2,0,0},{0,0,0,0},{0,0,0,0}})};
nBE=1/(Exp[ He/T]-1);
Ps=( He^2/dphi)^2/(2*Pi)^2*(1+ thermal*2*nBE+(T/He)*2*Sqrt[3]*Pi*Qe/Sqrt[3+4*Pi*Qe]);
];


FindICs[Qi_,Qf_]:=Module[{},
Clear[c,p];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,T,H,a,b,x,y,r];
DefinitionsWI[];
EqsWI[];

If[Qf>Qi,
Scan[If[#[[1]] =!= "stdout" && #[[1]] =!= "stderr", Close[#]] &, Streams[]];
If[FileExistsQ[fileICs], DeleteFile[fileICs]];
filedata=OpenWrite[fileICs];
If[FileExistsQ[filepowers], DeleteFile[filepowers]];
cp=OpenWrite[filepowers];
];

Q0i=Qi;
pQ0i=Log10[Q0i];
qQ0i=pQ0i;
While[Q0i<=Qf,
While[pQ0i<qQ0i+1,
{
If[Q0i<=Qf,
{
Qstar0=N[Q0i];
Print["Finding the  ICs for Ntot="," ",Ns,"  ","efolds of inflation and for Q=",Qstar0];
(Label[begin0];
CUpsilonl=Solve[Q==Qe,CUpsilon][[1]][[1]][[2]];
(* Loop to find initial conditions for N=Ntot *)
xstar0=xi;
BackgroundWI0[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signleft=Re[Sign[epsilon0[Ntot]-1]],signleft=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
If[signleft>0,
{If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon];
Goto[begin0];}];
While[ signleft<0, 
If[max==0,xstari=xstar0*0.99,xstari=xstar0*1.01];
xstar0=xstari;
(* Initial conditions for dphi and rad *)
BackgroundWI0[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signleft=Re[Sign[epsilon0[Ntot]-1]],signleft=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
];
xstari=xstar0;
If[max==0,xstarf=xstar0*1.01,xstarf=xstar0*0.99];
xstar0=xstarf;
BackgroundWI0[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signright=Re[Sign[epsilon0[Ntot]-1]],signright=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
a1=xstari;
b1=xstarf;
For[i=1,i<=30,
m1=(a1+b1)/2;
xstar0=m1;
(* Initial conditions for dphi and rad *)
BackgroundWI0[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
sm=If[hybrid==0,Re[Sign[epsilon0[Ntot]-1]],Re[Sign[xc/Abs[phi[Ntot]]-1]]];
If[sm== signleft,a1= m1,b1= m1;];i++
]);
phistar=xstar0;
ystar=dphii;
rstar=radi;
If[Qstar0<10^(-3),
If[max==0,xi=xstar0*1.05,xi=xstar0*0.98],xi=xstar0];
(*Print["Finding the  ICs: Successful"];*)

(* Value for the scale used, computed at Nback before N_* *) 
kvalue=Exp[Nback]*Hubble[Nback];
Nstar=Nback;

If[Qf>Qi,
Write[filedata,FortranForm[kvalue],SpaceForm[1],FortranForm[CUpsilon],SpaceForm[1],FortranForm[Qstar0],SpaceForm[1],
FortranForm[phistar],SpaceForm[1],FortranForm[ystar],SpaceForm[1],FortranForm[rstar],
SpaceForm[1],FortranForm[V0xstar]];
(* find T and field derivatives of Upsilon: used later on *)
Clear[c,p,T,x];
c=T*D[Log[Upsilon],T]/.{T->Temp[nn],x->phi[nn]}/.{nn-> 0};
p=x*D[Log[Upsilon],x]/.{T->Temp[nn],x->phi[nn]}/.{nn-> 0};
Write[cp,FortranForm[Qstar0],SpaceForm[1],FortranForm[c],SpaceForm[1],FortranForm[p]];
];
Clear[c,p];
Clear[CUpsilonl,xstar0,radi,dphii,CUpsilon,T,H,a,b,x,y,r];
}];
If[-9<pQ0i<-5,Q0i=Q0i+2.5*10^qQ0i,If[1<pQ0i<=2,Q0i=Q0i+0.5*10^qQ0i,
If[2<pQ0i<=3, Q0i=Q0i*1.1,
If[3<pQ0i<4, Q0i=Q0i*1.1,Q0i=Q0i+10^qQ0i]]]];
pQ0i=Log10[Q0i];
};
];
qQ0i=qQ0i+1;];
If[Qf>Qi,
Close[fileICs];
Close[filepowers];
Clear[filedata];
Clear[cp];
];
Clear[V0];
Print["Finding the  ICs: Successful. Data files saved."];
];


FindGQ[]:=Module[{},
Clear[c,p,CUpsilon,T,a,b,x,y,r,V0,syspert,ICspert,Cups,k];
DefinitionsWI[];
EqsWI[];

(*dataICs=Import[fileICs];*)
If[FileExistsQ[fileICs],dataICs=Import[fileICs],
(*If file not found,warn user*){Print["Data file ICs_data not found. Please run the commands
ParametersWI[] and then FindICs[Qi,Qf] with the appropriate Qi and Qf values. Aborting."];
Goto[endcode];}];

Scan[If[#[[1]] =!= "stdout" && #[[1]] =!= "stderr", Close[#]] &, Streams[]];
If[FileExistsQ[fileGQ], DeleteFile[fileGQ]];
filedataGQ=OpenWrite[fileGQ];

Nstar=Nback;
(* Read ICs and relevant parameters *)
ii=1;
While[ii<= Length[dataICs],
{
kvalue=dataICs[[ii]][[1]];
CUpsilon=dataICs[[ii]][[2]];
V0=dataICs[[ii]][[7]];
Cups=CUpsilon;
Qstar0=dataICs[[ii]][[3]];
phi0=dataICs[[ii]][[4]];
dphi0=dataICs[[ii]][[5]];
rad0=dataICs[[ii]][[6]];
z0 =z[t]/.{x[t]->phi0,y[t]->dphi0,r[t]->rad0};
ICs={x[0]==phi0,y[0]==dphi0,r[0]==rad0};
odesolver0[Npert];

Print["Finding now the value of G(Q) for Q=",Qstar0];

syspert=syspert0/.{k->kvalue,x[t]-> phi[t],y[t]-> dphi[t],r[t]->rad[t],a[t]->Exp[t],Qp[t]->Qdiss[t]};
ICspert=ICspert0/.{k->kvalue}/.{H0->z0,a0->1};
solnpert=NDSolve[{syspert/.{coupT-> 1},ICspert},Flatten[J[t]],{t,0,Npert},methodODE2]; 
firstIF=solnpert[[1,1,2]];  
domain=firstIF[[0,1]];
Npertstop=domain[[1,-1]]; 
Jsol[t_]=Table[First[J[t][[i]][[j]]/.solnpert],{i,Length[J[t]]},{j,Length[J[t]]}];
Cmatrix[t_]={{dphi[t],0,0,-1}};
Spectrum[t_]=Abs[(k^3/.{k->kvalue})/(2*Pi^2)*Hubble[t]^2/(dphi[t]^2+4/3*rad[t])^2*(Cmatrix[t] . Jsol[t] . Transpose[Cmatrix[t]])[[1]][[1]]];
Pst[t_]=Ps/.{T->Tt[t]}/.{dphi-> dphi[t],r[t]->rad[t],He->Hubble[t],Qe->Qdiss[t]};
Print["Q_*=",Qdiss[Nstar]," , ","Spectrum=",Abs[Spectrum[Npertstop]]," , ","Ps=",Pst[Nstar]," , ","GQ*=",Abs[Spectrum[Npertstop]]/Pst[Nstar]];
Write[filedataGQ,FortranForm[Qdiss[Nstar]],SpaceForm[1],FortranForm[Abs[Spectrum[Npertstop]]/Pst[Nstar]]];
ii=ii+1;
}];

Close[fileGQ];
Clear[filedataGQ];
Clear[V0];

Print["Finding G(Q): Successful. Data file saved."];
Label[endcode];
];


ObservationsWI[Q0spec_,x0value_]:=Module[{},
Clear[CUpsilonl,dphistarn,xstar0,V0,V0xstar,radi,dphii,CUpsilon,
T,H,a,b,x,y,r,V0,Nstar,Qstar0,Spectrum];

DefinitionsWI[];
EqsWI[];

Print["Running now spectrum code for Q=",N[Q0spec],".","Finding the  ICs for Ntot="," ",Ns,"  ","efolds of inflation and then normalizing the spectrum."];
(*datacp=Import[filepowers];*)
If[FileExistsQ[filepowers],datacp=Import[filepowers],
(*If file not found,warn user*){Print["Data file cp_data not found. Please run the commands
ParametersWI[] and then FindICs[Qi,Qf] with the appropriate Qi and Qf values. Aborting."];
Goto[endcode];}];
(* Interpolation function for the G(Q) function multiplying the spectrum *)
If[FileExistsQ[fileGQ],dataGQ=Import[fileGQ],
(*If file not found,warn user*){Print["Data file G(Q)_data not found. Please run the command
FindGQ[]. Aborting."];
Goto[endcode];}];
gqdata=Table[{dataGQ[[k]][[1]],dataGQ[[k]][[2]]},{k,Length[dataGQ]}];
gqfunc=Interpolation[gqdata, Method->"Spline",InterpolationOrder->2];
cdata=Table[{datacp[[k]][[1]],datacp[[k]][[2]]},{k,Length[datacp]}];
cfunc=Interpolation[cdata, Method->"Spline",InterpolationOrder->2];
pdata=Table[{datacp[[k]][[1]],datacp[[k]][[3]]},{k,Length[datacp]}];
pfunc=Interpolation[pdata, Method->"Spline",InterpolationOrder->2];
xi=x0value;
Qstar0=N[Q0spec];
If[Qstar0 < dataGQ[[1]][[1]] || Qstar0>dataGQ[[Length[dataGQ]]][[1]], 
{Print["Chosen value of Q is outside of the range of the values in G(Q) 
datafile. Choose another value."];
Goto[endcode];}]; 
(Label[begin];
(Label[begin0];
CUpsilonl=Solve[Q==Qe,CUpsilon][[1]][[1]][[2]];
Gfunc=gqfunc[Qstar];
(*dphistarn=Sqrt[(Solve[Cr0*Tstar^4==3*Qstar*dphistar^2/4,dphistar][[1]][[1]][[2]])^2];*)
dphistarn=Sqrt[4 Cr0 Tstar^4]/(Sqrt[3] Sqrt[Qstar]);
Psn=(Ps*Gfunc/.{He->Hstar,T->Tstar,dphi->dphistar,Qe->Qstar}/.{dphistar-> dphistarn})/.{Tstar->THstar*Hstar};
THstarn=NSolve[(Psn/.{Qstar-> Qstar0})== Pcurv,THstar,Reals][[1]][[1]][[2]];
If[THstarn<0,THstarn=NSolve[(Psn/.{Qstar-> Qstar0})== Pcurv,THstar,Reals][[2]][[1]][[2]]];
dphistarn=-dpotstar/(3*Hstar(1+Qstar));
Psn=(Ps*Gfunc/.{He->Hstar,T->Tstar,dphi->dphistar,Qe->Qstar}/.{dphistar-> dphistarn})/.{Tstar->THstar*Hstar};
rad0=Cr0*Tstar^4;
(*******************************************************************)
(* Loop to find initial conditions and V0 satisfying spectrum normalization for N=Ntot *)
(* Add all normalizations so to obtain the constant V0 that satisfies the CMB normalization *)
xstar0=xi;
BackgroundWI[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signleft=Re[Sign[epsilon0[Ntot]-1]],signleft=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
If[signleft>0,
{If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon];
Goto[begin0];}];
While[ signleft<0, 
If[max==0,xstari=xstar0*0.99,xstari=xstar0*1.01];
xstar0=xstari;
BackgroundWI[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signleft=Re[Sign[epsilon0[Ntot]-1]],signleft=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
];
xstari=xstar0;
If[max==0,xstarf=xstar0*1.01,xstarf=xstar0*0.99];
xstar0=xstarf;
BackgroundWI[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
If[hybrid==0,signright=Re[Sign[epsilon0[Ntot]-1]],signright=Re[Sign[xc/Abs[phi[Ntot]]-1]]];
a1=xstari;
b1=xstarf;
For[i=1,i<=30,
m1=(a1+b1)/2;
xstar0=m1;
BackgroundWI[];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
While[Nstop < Ntot, {If[max==0,xi=xstar0*1.05,xi=xstar0*0.99];
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,Nstop];Goto[begin0];}];
sm=If[hybrid==0,Re[Sign[epsilon0[Ntot]-1]],Re[Sign[xc/Abs[phi[Ntot]]-1]]];
If[sm== signleft,a1= m1,b1= m1;];i++
]);
Clear[m1];
phistar=xstar0;
ystar=dphii;
rstar=radi;
V0=V0xstar;
(* 
Evolving backwards the slow-roll equations (in dimensionless units)
*)
(* ODE system. t here is number of efolds N *)
sysslowroll={xe'[t]==-(dxdNsra/.{cTx->cfunc[Qe],pTx->pfunc[Qe]}/.{x->xe[t],Qe->Qe[t]}),
Qe'[t]==-(dQdNsra/.{cTx->cfunc[Qe],pTx->pfunc[Qe]}/.{x->xe[t],Qe->Qe[t]}),
ve'[t]==-(dvdNsra/.{cTx->cfunc[Qe],pTx->pfunc[Qe]}/.{x->xe[t],Qe->Qe[t],ve->ve[t]})};
ICsslowroll={xe[0]==xstar0,Qe[0]==Qstar0,ve[0]==TH[0]};
solslowroll=NDSolve[{sysslowroll,ICsslowroll},{xe,Qe,ve},{t,0,Nback},methodODE1];
phisr[nn_]=Re[First[xe[nn]/.solslowroll]];
Qsr[nn_]=Re[First[Qe[nn]/.solslowroll]];
THsr[nn_]=Re[First[ve[nn]/.solslowroll]];
xback=phisr[Nback];
Qback=Qsr[Nback];
THback=THsr[Nback];
(* Use the values obtained for xback and Qback to get corresponding dphi/dt and \rho_rad -- repeat a few times to get better approximated values *)
zback=Sqrt[(pot/.x->xback)]/Sqrt[3];
yback=-(dpot/.x-> xback)/(3*zback*(1+Qback));
rback=3*Qback*yback^2/4;
zback=Sqrt[yback^2/2+(pot/.x->xback)+rback]/Sqrt[3];
yback=-(dpot/.x-> xback)/(3*zback*(1+Qback));
rback=3*Qback*yback^2/4;
zback=Sqrt[yback^2/2+(pot/.x->xback)+rback]/Sqrt[3];
yback=-(dpot/.x-> xback)/(3*zback*(1+Qback));
rback=3*Qback*yback^2/4;
zback=Sqrt[yback^2/2+(pot/.x->xback)+rback]/Sqrt[3];
yback=-(dpot/.x-> xback)/(3*zback*(1+Qback));
Cr[t_]=Cr0;
(* Now evolving forward from Nback efolds before Nstar *)
ICs={x[0]==xback,y[0]==yback,r[0]==rback};
Clear[Nstop];
odesolver1[Ntot+Nback+10];
Nstop=(x["Domain"]/. soln[[1]])[[1,-1]];
spectrum[nn_]= (Ps*Gfunc/.{He->z[t],T->Tt[t],dphi->y[t],Qe->Q0[t]}/.{Qstar->Q0[t]})/.{Exp[t]->Exp[nn],x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]};
ns[nn_]= 1+ReplaceAll[ReplaceAll[D[(Log[(Ps*Gfunc/.{He->z[t],T->Tt[t],dphi->y[t],Qe->Q0[t]}/.{Qstar->Q0[t]})]),t],{x'[t]->y[t]/z[t],y'[t]-> -3(1+Q0[t])y[t]-(dpot/.{x->x[t]})/z[t],r'[t]-> -4r[t]+3Q0[t]y[t]^2}],{Exp[t]->Exp[nn],x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]}]/(1-epsilon0[nn]);
eps[t_]=1/(6 z[t]^2) (4 r[t]+3y[t]^2);
dns[nn_]=ReplaceAll[ReplaceAll[D[(ReplaceAll[D[(Log[(Ps*Gfunc/.{He->z[t],T->Tt[t],dphi->y[t],Qe->Q0[t]}/.{Qstar->Q0[t]})]),t],{x'[t]->y[t]/z[t],y'[t]-> -3(1+Q0[t])y[t]-(dpot/.{x->x[t]})/z[t],r'[t]-> -4r[t]+3Q0[t]y[t]^2}]/(1-eps[t])),t],{x'[t]->y[t]/z[t],y'[t]-> -3(1+Q0[t])y[t]-(dpot/.{x->x[t]})/z[t],r'[t]-> -4r[t]+3Q0[t]y[t]^2}],{Exp[t]->Exp[nn],x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]}]/(1-epsilon0[nn]);
(* Because V0 was found using slow-roll approximation, adjust
initial value of efolds from 0 to ni\[Equal]N_* so to obtain correct value
for the CMB amplitude normatization *)
Nstar=FindRoot[spectrum[ni]==Pcurv,{ni,Nback,Nback/10,2Nback}][[1]][[2]];
Nend=Nstar;
endinflation[t_]=If[hybrid==0,epsilon0[t],xc/phi[t]];
While[endinflation[Nend]<1 ,Nend=Nend+0.0005;];
(*Compute number of efolds of reheating from the end of inflation until w\sim 1/3 *)
wre[t_]=(-(pot/.x-> phi[t])+dphi[t]^2/2+rad[t]/3)/((pot/.x-> phi[t])+dphi[t]^2/2+rad[t])/.{V0-> V0xstar};
Nre=Nend;
If[hybrid==0,While[wre[Nre]<0.33 && Nre<=Nstop,Nre=Nre+0.0005;]];
condition=Re[(Mpl*Hubble[Nstar]/Hubble0)* (43/11/gstar0)^(1/3)TCMB/(Mpl^4*rad[Nre]/Cr[Nre])^(1/4)Exp[-(Nre-Nstar)] * Hubble0/kpivot];
(*If[condition<0.9 ||condition>1.1,*)
If[Abs[1-condition]>0.03,
{
Ntot=Ntot-(Nre-(Nstar+Log[Re[(Mpl*Hubble[Nstar]/Hubble0)* (43/11/gstar0)^(1/3)TCMB/(Mpl^4*rad[Nre]/Cr[Nre])^(1/4)Hubble0/kpivot]]))+RandomReal[{-0.15,0.15}];
xi=xstar0;
Clear[CUpsilonl,dphistarn,Psn,THstarn,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,V0];
Goto[begin];}];
rtensor[nn_]=(2*Hubble[nn]^2/Pi^2)/spectrum[nn];
);
Print["Running of main code for the observables: Successful."];
Print["epsilon(Nfinal)=",epsilon0[Nend]," , ","spectrum(N_*)=",spectrum[Nstar]," , ","C_Upsilon=",CUpsilon," , ","V_0=",V0xstar," , ",
"Q_*=",Qdiss[Nstar]," , ","r(N_*)=",rtensor[Nstar]," , ","ns(N_*)=",ns[Nstar]," , ","alphas(N_*)=",dns[Nstar]];
mainresults={CUpsilon,V0xstar,Qdiss[Nstar],rtensor[Nstar],ns[Nstar],dns[Nstar]};
Clear[V0];
Return[mainresults];
Label[endcode];
];


QrangeWI[QVal_]:=Module[{},
Clear[CUpsilonl,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,T,H,a,b,x,y,r,V0,Nstar,Qstar0,Spectrum];
DefinitionsWI[];

(*dataICs=Import[fileICs];*)
If[FileExistsQ[fileICs],dataICs=Import[fileICs],
(*If file not found,warn user*){Print["Data file ICs_data not found. Please run the commands
ParametersWI[] and then FindICs[Qi,Qf] with the appropriate Qi and Qf values. Aborting."];
Goto[endcode];}];
(* Interpolation function for the G(Q) function multiplying the spectrum *)
(*dataGQ=Import[fileGQ];*)
If[FileExistsQ[fileGQ],dataGQ=Import[fileGQ],
(*If file not found,warn user*){Print["Data file G(Q)_data not found. Please run the command
FindGQ[]. Aborting."];
Goto[endcode];}];
Scan[If[#[[1]] =!= "stdout" && #[[1]] =!= "stderr", Close[#]] &, Streams[]];
If[FileExistsQ[fileobs], DeleteFile[fileobs]];
filedataobs=OpenWrite[fileobs];
Print["Finding observables as a function of \!\(\*SubscriptBox[\(Q\), \(*\)]\)"];
(* Read ICs and relevant parameters *)
ii=1;
While[QVal>dataICs[[ii]][[3]],ii++ ];
While[ii<= Length[dataICs],
{
If[dataICs[[ii]][[3]] < dataGQ[[1]][[1]] || dataICs[[ii]][[3]] > dataGQ[[Length[dataGQ]]][[1]],Goto[end]];
Clear[CUpsilonl,dphistarn,xstar0,V0xstar,radi,dphii,CUpsilon,T,H,a,b,x,y,r,V0,Nstar,Nend,Nre];
ObservationsWI[dataICs[[ii]][[3]],dataICs[[ii]][[4]]];
Write[filedataobs,FortranForm[Qdiss[Nstar]],SpaceForm[1],FortranForm[CUpsilon],SpaceForm[1],
FortranForm[V0xstar],SpaceForm[1],FortranForm[Nend-Nstar],SpaceForm[1],FortranForm[Nre-Nstar],
SpaceForm[1],FortranForm[phi[Nstar]],
SpaceForm[1],FortranForm[Abs[phi[Nstar]-phi[Nend]]],SpaceForm[1],FortranForm[TH[Nstar]],
SpaceForm[1],FortranForm[Hubble[Nstar]],
SpaceForm[1],FortranForm[Temp[Nstar]],SpaceForm[1],FortranForm[rtensor[Nstar]],SpaceForm[1],
FortranForm[ns[Nstar]],SpaceForm[1],FortranForm[dns[Nstar]]];
If[ns[Nstar]>0.99 || ns[Nstar]<0.93,ii=Length[dataICs]];
Label[end];
ii=ii+1;
}];
Close[fileobs];
Clear[filedataobs];
Clear[V0];
Print["Finding observables as a function of Q: Successful. Data file saved."];
Label[endcode];
];


BackgroundWI0[]:=Module[{},
Clear[V0,V0xstar];
V0xstar=V0init;
V0=V0xstar; 
(* Initial conditions for dphi and rad *)
dphii=N[dphistarn/.{Qstar-> Qstar0,Hstar->Hsr,dpotstar-> dpot}/.{x->xstar0}];
radi=rad0/.{Qstar-> Qstar0};
CUpsilon = CUpsilonl/.{Qe->Qstar0, rad->radi, dphi->dphii,phi-> xstar0,x-> xstar0}/.{V0-> V0xstar};
(* ODE system. t here is number of efolds N *)
ICs={x[0]==xstar0,y[0]==dphii,r[0]==radi};
odesolver0[Ntot];
];


BackgroundWI[]:=Module[{},
Clear[V0,V0xstar];
V0xstar=Solve[((((Psn/.{dphi->dphistar,T->Hstar*THstar,
Qe->Qstar,He->Hstar}/.{THstar->THstarn,dphistar->dphistarn})
/.{Qstar-> Qstar0,Tstar->THstarn*Hstar})
/.{Hstar->Hsr,dpotstar-> dpot})/.{x->xstar0})==Pcurv,V0,Reals,Assumptions->V0>0][[1]][[1]][[2]];
(*V0xstar=FindRoot[((((Psn/.{dphi\[Rule]dphistar,T->Hstar*THstar,Qe->Qstar,He->Hstar}
/.{THstar->THstarn,dphistar->dphistarn})
/.{Qstar\[Rule] Qstar0,Tstar\[Rule]THstarn*Hstar})
/.{Hstar\[Rule]Hsr,dpotstar\[Rule] dpot})/.{x\[Rule]xstar0})\[Equal]Pcurv,{V0,V0init}][[1]][[2]];*)
(* Initial conditions for dphi and rad *)
dphii=N[(((-dpotstar/(3*Hstar(1+Qstar)))/.{Qstar-> Qstar0,Hstar->Hsr,dpotstar-> dpot})/.{x->xstar0}/.{V0-> V0xstar})];
radi=((rad0/.{Tstar->THstarn*Hsr})/.{x->xstar0})/.{V0-> V0xstar};
CUpsilon = CUpsilonl/.{Qe->Qstar0, rad->radi, dphi->dphii,phi-> Mp*xstar0,x-> xstar0}/.{V0-> V0xstar};
ICs={x[0]==xstar0,y[0]==dphii,r[0]==radi};
odesolver1[Ntot];
];


odesolver0[nefolds_]:=Module[{},
V0xstar=V0init;
soln=If[max==0,NDSolve[{sys/.{V0-> V0xstar},ICs},{x,y,r},{t,0,nefolds},methodODE0],
NDSolve[{sys/.{V0-> V0xstar},ICs,
WhenEvent[stopCondition[t,x[t],y[t],r[t],V0xstar]>=
If[hybrid==0,1.999,1.02],
{Nstop=t,"StopIntegration"}(*,"DetectionMethod"->"Interpolation",
"LocationMethod"->"LinearInterpolation"*) ,"DetectionMethod"->"DerivativeSign"]},{x,y,r},{t,0,nefolds},methodODE0]];
phi[nn_]=Re[First[x[nn]/.soln]];
dphi[nn_]=Re[First[y[nn]/.soln]];
rad[nn_]=Re[First[r[nn]/.soln]];
epsilon0[nn_]=Re[epsilon[t]/.{x[t]-> phi[nn],y[t]->dphi[nn],r[t]-> rad[nn]}/.{V0-> V0xstar}];
Qdiss[nn_]=Q0[t]/.{x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]};
Hubble[nn_]=z[t]/.{x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]};
Temp[nn_] = Tt[t]/.{r[t]->rad[nn]};
TH[nn_]=Temp[nn]/Hubble[nn];
];


odesolver1[nefolds_]:=Module[{},
soln=If[max==0,NDSolve[{sys/.{V0-> V0xstar},ICs},{x,y,r},{t,0,nefolds},methodODE1],
NDSolve[{sys/.{V0-> V0xstar},ICs,
WhenEvent[stopCondition[t,x[t],y[t],r[t],V0xstar]>=
If[hybrid==0,1.999,1.02],
{Nstop=t,"StopIntegration"}(*,"DetectionMethod"->"Interpolation",
"LocationMethod"->"LinearInterpolation"*),"DetectionMethod"->"DerivativeSign"]},{x,y,r},{t,0,nefolds},methodODE1]];
phi[nn_]=Re[First[x[nn]/.soln]];
dphi[nn_]=Re[First[y[nn]/.soln]];
rad[nn_]=Re[First[r[nn]/.soln]];
epsilon0[nn_]=Re[epsilon[t]/.{x[t]-> phi[nn],y[t]->dphi[nn],r[t]-> rad[nn]}/.{V0-> V0xstar}];
Qdiss[nn_]=Q0[t]/.{x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]};
Hubble[nn_]=z[t]/.{x[t]->phi[nn],y[t]->dphi[nn],r[t]->rad[nn]};
Temp[nn_] = Tt[t]/.{r[t]->rad[nn]};
TH[nn_]=Temp[nn]/Hubble[nn];
];


(* Make several plots *)
MakePlotsEvolution :=
  Module[{},
  Print["Making background plots for \!\(\*SubscriptBox[\(Q\), \(*\)]\)=",Qstar0];
SetDirectory[NotebookDirectory[]]
SetOptions[OpenWrite,PageWidth->Infinity];

If[hybrid==0,
{pepsilon=LogPlot[epsilon0[t+Nstar],{t,0,Nend-Nstar},PlotStyle->{Black},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["\!\(\*SubscriptBox[\(\[Epsilon]\), \(H\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pepsilon];}];

pQ=LogPlot[Qdiss[t+Nstar],{t,0,Nend-Nstar},PlotStyle->{Black},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["Q",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pQ];

pTH=LogPlot[{TH[t+Nstar],1},{t,0,Nend-Nstar},PlotStyle->{Black,{Gray,Thin}},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["T/H",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pTH];

pT=LogPlot[Temp[t+Nstar],{t,0,Nend-Nstar},PlotStyle->{Black},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["T/\!\(\*SubscriptBox[\(M\), \(Pl\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pT];

pphi=LogPlot[phi[t+Nstar],{t,0,Nend-Nstar},PlotStyle->{Black},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["\[Phi]/\!\(\*SubscriptBox[\(M\), \(Pl\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pphi];

If[hybrid==0,
{penergies=LogPlot[{(pot/.{x->phi[t+Nstar],V0->V0xstar}),dphi[t+Nstar]^2/2,rad[t+Nstar]},{t,0,Nre-Nstar},PlotStyle->{Blue,{Green,Dashed},{Red,DotDashed}},Frame-> True,
FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black]},FrameTicksStyle -> Directive[Black, 12],
PlotLegends->Placed[{Style["V",Italic,12],Style["\!\(\*FractionBox[SuperscriptBox[OverscriptBox[\(\[Phi]\), \(.\)], \(2\)], \(2\)]\)",Italic,12],Style["\!\(\*SubscriptBox[\(\[Rho]\), \(rad\)]\)",Italic,12]},{Left,Bottom}],PlotRange->All];
Print[penergies];

pw=Plot[wre[t+Nstar],{t,0,Nre-Nstar},PlotStyle->{Black},Frame-> True,FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)-\!\(\*SubscriptBox[\(N\), \(*\)]\)",  14, Italic,Black],Style["\!\(\*SubscriptBox[\(w\), \(total\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All];
 Print[pw];}
 ];

(* Spectrum as a function of the number of efolds and as a function of k *)
Print["Spectrum as a function of the number of efolds, \!\(\*SubscriptBox[\(k\), \(*\)]\)/\!\(\*SubscriptBox[\(k\), \(pivot\)]\),
and \!\(\*SubscriptBox[\(k\), \(*\)]\). Results are cut at maximum Q in the G(Q) data to avoid going beyond a region where data
are not available."];

dataGQ=Import[fileGQ];
Qmax=dataGQ[[Length[dataGQ]]][[1]];
If[Qdiss[Nend]>Qmax,Nmax = FindRoot[Qdiss[t]==Qmax,{t,1,Nend}][[1]][[2]],Nmax=Nend];

p1Pr=LogPlot[spectrum[t],{t,0,Nmax},PlotStyle->{Black},Frame->True,
FrameLabel->{Style["\!\(\*SubscriptBox[\(N\), \(e\)]\)",14,Italic,Black],
Style["\!\(\*SubscriptBox[\(P\), \(\[ScriptCapitalR]\)]\)",Italic,14,Black]},FrameTicksStyle->Directive[Black,12],
PlotRange->All,GridLines->{{{Nstar,Red}},{{Pcurv,Red}}}];
Print[p1Pr];

p2Pr=ListLogLogPlot[Table[{Exp[t]Hubble[t]/(Exp[Nstar]Hubble[Nstar]),spectrum[t]},{t,0,Nmax,0.5}],
PlotStyle->{Black},Frame-> True,Joined->True, 
FrameLabel->{Style["\!\(\*SubscriptBox[\(k\), \(*\)]\)/\!\(\*SubscriptBox[\(k\), \(p\)]\)",  14, Italic,Black],
Style["\!\(\*SubscriptBox[\(P\), \(\[ScriptCapitalR]\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All,GridLines->{{{1,Red}},{{Pcurv,Red}}}];
Print[p2Pr];

p3Pr=ListLogLogPlot[Table[{Exp[t]Hubble[t]/(Exp[Nstar]Hubble[Nstar])*kpivotscale,spectrum[t]},{t,0,Nmax,0.5}],
PlotStyle->{Black},Frame-> True,Joined->True, 
FrameLabel->{Style["\!\(\*SubscriptBox[\(k\), \(*\)]\)[\!\(\*SuperscriptBox[\(Mpc\), \(-1\)]\)]",  14, Italic,Black],
Style["\!\(\*SubscriptBox[\(P\), \(\[ScriptCapitalR]\)]\)",Italic,14,Black]},
 FrameTicksStyle -> Directive[Black, 12],PlotRange->All,GridLines->{{{kpivotscale,Red}},{{Pcurv,Red}}}];
Print[p3Pr];
];


End[] (* End Private Context *)

EndPackage[]
